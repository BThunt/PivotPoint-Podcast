#!/usr/bin/env python3
"""
Audio Chunk Combiner

Combines multiple audio chunk files into a single audio file.
Useful for combining temp_audio_chunk_*.mp3 files generated by the podcast system.
"""

import sys
import argparse
import glob
import re
from pathlib import Path

def install_pydub():
    """Install pydub if not available."""
    try:
        import subprocess
        print("Installing pydub...")
        subprocess.check_call([sys.executable, "-m", "pip", "install", "pydub"])
        print("‚úì pydub installed successfully")
    except Exception as e:
        print(f"‚úó Failed to install pydub: {e}")
        print("Please install manually: pip install pydub")
        sys.exit(1)

def check_ffmpeg():
    """Check if ffmpeg is available."""
    import subprocess
    try:
        subprocess.run(['ffmpeg', '-version'], capture_output=True, check=True)
        return True
    except (subprocess.CalledProcessError, FileNotFoundError):
        return False

def install_ffmpeg_instructions():
    """Provide instructions for installing ffmpeg."""
    print("\n" + "="*50)
    print("‚ö†Ô∏è  FFMPEG REQUIRED")
    print("="*50)
    print("pydub requires ffmpeg to process MP3 files.")
    print("\nInstallation options:")
    print("\nüç∫ macOS (using Homebrew):")
    print("  brew install ffmpeg")
    print("\nüêß Linux (Ubuntu/Debian):")
    print("  sudo apt update && sudo apt install ffmpeg")
    print("\nü™ü Windows:")
    print("  1. Download from: https://ffmpeg.org/download.html")
    print("  2. Add to PATH environment variable")
    print("\nAfter installing ffmpeg, run this script again.")
    print("="*50)

def simple_mp3_combine(chunk_files, output_file):
    """Simple MP3 concatenation using raw bytes (less reliable but no dependencies)."""
    print("\n‚ö†Ô∏è  Using simple byte concatenation (may have audio glitches)")
    print("For best results, install ffmpeg and use the full pydub method.")
    
    try:
        with open(output_file, 'wb') as outfile:
            for i, chunk_file in enumerate(chunk_files):
                print(f"  Appending chunk {i+1}/{len(chunk_files)}: {Path(chunk_file).name}")
                with open(chunk_file, 'rb') as infile:
                    # Skip MP3 header for subsequent files to avoid glitches
                    if i > 0:
                        # Skip first 1024 bytes which typically contain MP3 headers
                        infile.read(1024)
                    outfile.write(infile.read())
        
        print(f"‚úì Combined {len(chunk_files)} chunks using simple concatenation")
        print(f"‚úì Output file: {output_file}")
        print("\nüí° Note: For seamless audio, install ffmpeg and re-run this script")
        return True
        
    except Exception as e:
        print(f"‚úó Error in simple concatenation: {e}")
        return False

def combine_audio_chunks(directory: str, output_file: str = None, pattern: str = "temp_audio_chunk_*.mp3"):
    """
    Combine audio chunks in the specified directory.
    
    Args:
        directory: Directory containing the audio chunks
        output_file: Output filename (optional, defaults to daily_briefing.mp3)
        pattern: File pattern to match (default: temp_audio_chunk_*.mp3)
    """
    directory_path = Path(directory)
    if not directory_path.exists():
        print(f"‚úó Directory not found: {directory}")
        return False
    
    # Find all chunk files
    chunk_pattern = str(directory_path / pattern)
    chunk_files = glob.glob(chunk_pattern)
    
    if not chunk_files:
        print(f"‚úó No audio chunks found matching pattern: {pattern}")
        print(f"  Searched in: {directory_path}")
        return False
    
    # Sort files by chunk number
    def extract_chunk_number(filename):
        match = re.search(r'chunk_(\d+)', filename)
        return int(match.group(1)) if match else 0
    
    chunk_files.sort(key=extract_chunk_number)
    print(f"Found {len(chunk_files)} audio chunks:")
    for i, file in enumerate(chunk_files):
        print(f"  {i+1}. {Path(file).name}")
    
    # Determine output filename
    if output_file is None:
        output_file = str(directory_path / "daily_briefing.mp3")
    elif not Path(output_file).is_absolute():
        output_file = str(directory_path / output_file)
    
    # Try pydub with ffmpeg first, fallback to simple concatenation
    try:
        from pydub import AudioSegment
        
        # Check if ffmpeg is available
        if not check_ffmpeg():
            print("‚ö†Ô∏è  ffmpeg not found. Trying simple concatenation...")
            return simple_mp3_combine(chunk_files, output_file)
        
        # Combine audio files using pydub
        print("\nCombining audio chunks with pydub + ffmpeg...")
        combined_audio = AudioSegment.empty()
        
        for i, chunk_file in enumerate(chunk_files):
            try:
                print(f"  Processing chunk {i+1}/{len(chunk_files)}: {Path(chunk_file).name}")
                audio_chunk = AudioSegment.from_mp3(chunk_file)
                combined_audio += audio_chunk
            except Exception as e:
                print(f"  ‚úó Error processing {chunk_file}: {e}")
                print("Falling back to simple concatenation...")
                return simple_mp3_combine(chunk_files, output_file)
        
        # Export combined audio
        try:
            print(f"\nExporting combined audio to: {output_file}")
            combined_audio.export(output_file, format="mp3")
            
            # Get duration info
            duration_seconds = len(combined_audio) / 1000
            duration_minutes = duration_seconds / 60
            
            print(f"‚úì Successfully combined {len(chunk_files)} chunks with pydub")
            print(f"‚úì Total duration: {duration_minutes:.1f} minutes ({duration_seconds:.1f} seconds)")
            print(f"‚úì Output file: {output_file}")
            
            return True
            
        except Exception as e:
            print(f"‚úó Error exporting combined audio: {e}")
            print("Falling back to simple concatenation...")
            return simple_mp3_combine(chunk_files, output_file)
    
    except ImportError:
        print("pydub not found. Installing...")
        install_pydub()
        # After installation, try again but fallback to simple if ffmpeg missing
        return combine_audio_chunks(directory, output_file, pattern)
    
    except Exception as e:
        print(f"‚úó Unexpected error with pydub: {e}")
        print("Falling back to simple concatenation...")
        return simple_mp3_combine(chunk_files, output_file)

def find_podcast_directories():
    """Find podcast run directories in the current directory."""
    current_dir = Path(".")
    podcast_dirs = []
    
    for item in current_dir.iterdir():
        if item.is_dir() and item.name.startswith("podcast_run_"):
            # Check if it contains audio chunks
            chunk_files = list(item.glob("temp_audio_chunk_*.mp3"))
            if chunk_files:
                podcast_dirs.append((str(item), len(chunk_files)))
    
    return podcast_dirs

def main():
    parser = argparse.ArgumentParser(description="Combine audio chunks into a single file")
    parser.add_argument("directory", nargs="?", help="Directory containing audio chunks")
    parser.add_argument("-o", "--output", help="Output filename (default: daily_briefing.mp3)")
    parser.add_argument("-p", "--pattern", default="temp_audio_chunk_*.mp3", 
                       help="File pattern to match (default: temp_audio_chunk_*.mp3)")
    parser.add_argument("--list", action="store_true", help="List available podcast directories")
    
    args = parser.parse_args()
    
    if args.list or not args.directory:
        print("üéôÔ∏è  Audio Chunk Combiner")
        print("=" * 50)
        
        podcast_dirs = find_podcast_directories()
        if podcast_dirs:
            print("Found podcast directories with audio chunks:")
            for i, (dir_path, chunk_count) in enumerate(podcast_dirs, 1):
                print(f"  {i}. {dir_path} ({chunk_count} chunks)")
            
            if not args.directory:
                print(f"\nUsage: python {sys.argv[0]} <directory>")
                print("Example:")
                if podcast_dirs:
                    print(f"  python {sys.argv[0]} {podcast_dirs[0][0]}")
        else:
            print("No podcast directories with audio chunks found.")
            if not args.directory:
                print(f"\nUsage: python {sys.argv[0]} <directory>")
        
        if args.list:
            return
        if not args.directory:
            sys.exit(1)
    
    print("üéôÔ∏è  Combining Audio Chunks")
    print("=" * 50)
    
    success = combine_audio_chunks(args.directory, args.output, args.pattern)
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()